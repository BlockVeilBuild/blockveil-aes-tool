<!DOCTYPE html>

<html lang="bn">

<head>

  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Fully Decentralized Encrypt & Decrypt Generate Tool by BlockVeil</title>


  <style>

    :root{

      --bg:#f5f7fa;

      --card:#ffffff;

      --accent:#1f6feb;

      --green:#0a8a26;

      --text:#000000;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;

    }


    html,body{

      margin:0; padding:0; background:var(--bg);

      font-family:Inter,system-ui,Segoe UI,Roboto,Arial;

      color:var(--text);

      font-weight:700;

    }


    .wrap{

      max-width:480px; margin:0 auto; padding:18px;

    }


    h1{

      font-size:18px;

      margin-bottom:16px;

      text-align:center;

      font-weight:900;

    }


    .card{

      background:var(--card);

      padding:16px;

      margin-bottom:20px;

      border-radius:10px;

      box-shadow:0 4px 12px rgba(0,0,0,0.05);

      border:2px solid #000000;

    }


    .card-title{

      margin:0 0 10px;

      font-size:18px;

      font-weight:900;

      color:var(--green);

    }


    label{

      font-size:14px;

      margin-bottom:6px;

      display:block;

      font-weight:900;

    }


    textarea,input{

      width:100%;

      box-sizing:border-box;

      padding:10px;

      border-radius:8px;

      font-family:var(--mono);

      font-size:14px;

      background:#fafafa;

      border:2px solid #000000;

      font-weight:700;

    }


    textarea{

      resize:vertical;

      min-height:120px;

    }


    .controls{

      display:flex;

      flex-wrap:wrap;

      gap:10px;

      margin-top:10px;

    }


    button{

      padding:10px 14px;

      border-radius:8px;

      border:2px solid #000000;

      cursor:pointer;

      font-weight:900;

      background:var(--accent);

      color:white;

      flex:1;

    }


    .meta{

      margin-top:14px;

      display:flex;

      flex-direction:column;

      gap:10px;

    }


    .field{

      width:100%;

      font-weight:900;

    }


    .output{

      padding:10px;

      background:white;

      border-radius:8px;

      border:2px solid #000000;

      font-family:var(--mono);

      font-size:13px;

      min-height:42px;

      overflow:auto;

      filter:blur(5px);

      transition:.18s;

      font-weight:700;

      white-space:pre-wrap;

    }


    textarea.output{

      min-height:120px;

      resize:vertical;

    }


    .output.reveal{

      filter:none;

    }


    .label-row{

      display:flex;

      justify-content:space-between;

      align-items:center;

      gap:8px;

    }


    .paste-box{

      font-size:11px;

      padding:4px 8px;

      border-radius:6px;

      border:2px solid #000000;

      background:#eef3ff;

      cursor:pointer;

      font-weight:800;

      white-space:nowrap;

    }


    #decryptBtn.pending{

      background:#ffd94d;

      color:#000000;

    }


    input.error,

    textarea.error{

      border-color:#ff0000;

    }


    input.error::placeholder,

    textarea.error::placeholder{

      color:#ff0000;

      opacity:1;

    }

  </style>

</head>


<body>

  <div class="wrap">

    <h1>Fully Decentralized Encrypt & Decrypt Generate Tool by BlockVeil</h1>


    <div class="card">

      <h3 class="card-title">Encrypt</h3>


      <div class="label-row">

        <label>Plaintext</label>

        <div id="pastePlaintext" class="paste-box">Paste your text</div>

      </div>

      <p style="font-size:12px; margin:6px 0 10px; font-weight:700;">

        Write the text you want to encrypt in the box below.!

      </p>


      <textarea id="plaintext"></textarea>

      <div class="controls">

        <button id="encryptBtn">Encrypt</button>

      </div>


      <label style="margin-top:14px">Ciphertext (Base64)</label>

      <textarea id="ciphertext" readonly></textarea>


      <div class="meta">

        <div class="field">

          <label>Key (hex)</label>

          <div id="keyHex" class="output"></div>

        </div>


        <div class="field">

          <label>IV (hex)</label>

          <div id="ivHex" class="output"></div>

        </div>

      </div>

    </div>


    <div class="card">

      <h3 class="card-title">Decrypt</h3>


      <div class="label-row">

        <label>Ciphertext (Base64)</label>

        <div id="pasteCiphertextDec" class="paste-box">Paste here</div>

      </div>

      <textarea id="ciphertextDec"></textarea>


      <div class="label-row">

        <label>Key (hex)</label>

        <div id="pasteKeyDec" class="paste-box">Paste here</div>

      </div>

      <input id="keyHexDec" type="text">


      <div class="label-row">

        <label>IV (hex)</label>

        <div id="pasteIvDec" class="paste-box">Paste here</div>

      </div>

      <input id="ivHexDec" type="text">


      <div class="controls">

        <button id="decryptBtn" class="pending">Decrypt</button>

      </div>


      <label style="margin-top:14px">Plaintext</label>

      <textarea id="plaintextDec" class="output" readonly></textarea>

    </div>

  </div>


<script>

  const toHex = (a) => Array.from(a).map(b => b.toString(16).padStart(2,"0")).join("");


  function hexToBytes(h){

    if(!h) return new Uint8Array();

    if(h.length%2) throw "Invalid hex";

    let o = new Uint8Array(h.length/2);

    for(let i=0;i<o.length;i++) o[i] = parseInt(h.substr(i*2,2),16);

    return o;

  }


  function base64ToBytes(b){

    let s = atob(b), a = new Uint8Array(s.length);

    for(let i=0;i<s.length;i++) a[i] = s.charCodeAt(i);

    return a;

  }


  const plaintext    = document.getElementById("plaintext");

  const ciphertext   = document.getElementById("ciphertext");

  const keyHex       = document.getElementById("keyHex");

  const ivHex        = document.getElementById("ivHex");


  const ciphertextDec = document.getElementById("ciphertextDec");

  const keyHexDec     = document.getElementById("keyHexDec");

  const ivHexDec      = document.getElementById("ivHexDec");

  const plaintextDec  = document.getElementById("plaintextDec");


  const pastePlaintext     = document.getElementById("pastePlaintext");

  const pasteCiphertextDec = document.getElementById("pasteCiphertextDec");

  const pasteKeyDec        = document.getElementById("pasteKeyDec");

  const pasteIvDec         = document.getElementById("pasteIvDec");


  const decryptBtn         = document.getElementById("decryptBtn");


  async function copyToClipboard(text){

    if(!text) return;

    try{

      await navigator.clipboard.writeText(text);

    }catch(e){

      console.error("Copy failed", e);

    }

  }


  async function pasteIntoField(field){

    try{

      if(!navigator.clipboard || !navigator.clipboard.readText){

        alert("Clipboard is not available. Please paste manually.");

        return;

      }

      const text = await navigator.clipboard.readText();

      if(!text){

        alert("Clipboard is empty.");

        return;

      }

      field.value = text;

      field.focus();

      if(field === ciphertextDec || field === keyHexDec || field === ivHexDec){

        field.classList.remove("error");

        field.placeholder = "";

        updateDecryptState();

      }

    }catch(e){

      alert("Please allow clipboard permission in your browser and try again.");

      console.error("Paste failed", e);

    }

  }


  function updateDecryptState(){

    const hasCt  = ciphertextDec.value.trim().length > 0;

    const hasKey = keyHexDec.value.trim().length > 0;

    const hasIv  = ivHexDec.value.trim().length > 0;

    if(hasCt && hasKey && hasIv){

      decryptBtn.classList.remove("pending");

    }else{

      decryptBtn.classList.add("pending");

    }

  }


  function handleFieldInput(){

    if(this.value.trim()){

      this.classList.remove("error");

      this.placeholder = "";

    }

    updateDecryptState();

  }


  pastePlaintext.addEventListener("click", () => {

    pasteIntoField(plaintext);

  });

  pasteCiphertextDec.addEventListener("click", () => {

    pasteIntoField(ciphertextDec);

  });

  pasteKeyDec.addEventListener("click", () => {

    pasteIntoField(keyHexDec);

  });

  pasteIvDec.addEventListener("click", () => {

    pasteIntoField(ivHexDec);

  });


  ciphertextDec.addEventListener("input", handleFieldInput);

  keyHexDec.addEventListener("input", handleFieldInput);

  ivHexDec.addEventListener("input", handleFieldInput);


  ciphertext.addEventListener("click", () => {

    copyToClipboard(ciphertext.value.trim());

  });


  keyHex.addEventListener("click", () => {

    if(!keyHex.classList.contains("reveal")){

      keyHex.classList.add("reveal");

      return;

    }

    copyToClipboard(keyHex.textContent.trim());

  });


  ivHex.addEventListener("click", () => {

    if(!ivHex.classList.contains("reveal")){

      ivHex.classList.add("reveal");

      return;

    }

    copyToClipboard(ivHex.textContent.trim());

  });


  plaintextDec.addEventListener("click", () => {

    if(!plaintextDec.classList.contains("reveal")){

      plaintextDec.classList.add("reveal");

      return;

    }

    copyToClipboard(plaintextDec.value.trim());

  });


  document.getElementById("encryptBtn").onclick = async () => {

    const data   = new TextEncoder().encode(plaintext.value);

    const rawKey = crypto.getRandomValues(new Uint8Array(32));

    const iv     = crypto.getRandomValues(new Uint8Array(12));


    const key = await crypto.subtle.importKey(

      "raw",

      rawKey,

      {name:"AES-GCM"},

      false,

      ["encrypt"]

    );

    const buf = await crypto.subtle.encrypt({name:"AES-GCM",iv}, key, data);


    ciphertext.value   = btoa(String.fromCharCode(...new Uint8Array(buf)));

    keyHex.textContent = toHex(rawKey);

    ivHex.textContent  = toHex(iv);


    keyHex.classList.remove("reveal");

    ivHex.classList.remove("reveal");

  };


  decryptBtn.onclick = async () => {

    const ctVal  = ciphertextDec.value.trim();

    const keyVal = keyHexDec.value.trim();

    const ivVal  = ivHexDec.value.trim();


    [ciphertextDec, keyHexDec, ivHexDec].forEach(f => {

      f.classList.remove("error");

      f.placeholder = "";

    });


    const missing = [];

    if(!ctVal)  missing.push(ciphertextDec);

    if(!keyVal) missing.push(keyHexDec);

    if(!ivVal)  missing.push(ivHexDec);


    if(missing.length > 0){

      missing.forEach(f => {

        f.classList.add("error");

        f.placeholder = "Required Text for Decrypt";

      });

      alert("Text required!");

      return;

    }


    try{

      const ct       = base64ToBytes(ctVal);

      const keyBytes = hexToBytes(keyVal);

      const ivBytes  = hexToBytes(ivVal);


      const key = await crypto.subtle.importKey(

        "raw",

        keyBytes,

        {name:"AES-GCM"},

        false,

        ["decrypt"]

      );

      const buf = await crypto.subtle.decrypt({name:"AES-GCM",iv:ivBytes}, key, ct);


      const text = new TextDecoder().decode(buf);

      plaintextDec.value = text;

      plaintextDec.classList.remove("reveal");

    }catch(e){

      console.error("Decryption failed", e);

      alert("Please enter your right information for Decrypt.");

      plaintextDec.value = "";

      plaintextDec.classList.remove("reveal");

    }

  };


  window.addEventListener("beforeunload", () => {

    keyHex.textContent = "";

    ivHex.textContent  = "";

    keyHexDec.value    = "";

    ivHexDec.value     = "";

    plaintextDec.value = "";

    plaintextDec.classList.remove("reveal");

  });


  updateDecryptState();

</script>
<div style="text-align:center; margin-top:30px; padding:15px; font-size:0.9em; color:#444;">
  <p><strong>Why Trust This Tool?</strong></p>
  <p>This tool is completely open source and non-profitable. All encryption and decryption happen only on your device and no data is ever sent to the internet or any server. You can review the full source code on our <a href="https://github.com/BlockVeilBuild/blockveil-aes-tool" target="_blank">GitHub</a> to verify its safety yourself.</p>
  <p>This is a free tool made for everyone. We believe in transparency and security, so you can trust that your information stays yours.</p>
  <p><em>We build in silence.</em></p>
</div>
<footer style="text-align:center; margin-top:40px; padding:20px 0; font-size:0.9em; color:#555;">
  <p>Created by the <a href="https://blockveil.free.nf" target="_blank">BlockVeil Team</a>.  
  Source code on <a href="https://github.com/BlockVeilBuild/blockveil-aes-tool" target="_blank">GitHub</a>.</p>
</footer>
</body>

</html>
